package kafka;import org.apache.flink.api.common.functions.MapFunction;import org.apache.flink.api.java.tuple.*;import org.apache.flink.streaming.api.TimeCharacteristic;import org.apache.flink.streaming.api.datastream.DataStream;import org.apache.flink.streaming.api.datastream.KeyedStream;import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;import org.apache.flink.streaming.api.datastream.WindowedStream;import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;import org.apache.flink.streaming.api.functions.AssignerWithPeriodicWatermarks;import org.apache.flink.streaming.api.functions.windowing.WindowFunction;import org.apache.flink.streaming.api.watermark.Watermark;import org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;import org.apache.flink.streaming.api.windowing.time.Time;import org.apache.flink.streaming.api.windowing.windows.TimeWindow;import org.apache.flink.util.Collector;import javax.annotation.Nullable;import java.text.SimpleDateFormat;import java.util.*;/** * filename: WatermarkTest * Description: * Author: ubuntu * Date: 12/25/17 4:45 PM */public class WatermarkTest {    public static void main(String[] args) {        final SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");        StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment();        env.setParallelism(1);        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);        DataStream<String> data = env.socketTextStream("localhost", 9000);        DataStream<Tuple2<String, Long>> tuple1 = data.map(new MapFunction<String, Tuple2<String, Long>>() {            private static final long serialVersionUID = -5846473960253732231L;            @Override            public Tuple2<String, Long> map(String s) throws Exception {                String[] tt = s.split(",");                return new Tuple2<>(tt[0], Long.parseLong(tt[1]));            }        });        DataStream<Tuple2<String, Long>> tuple2 = tuple1.assignTimestampsAndWatermarks(new BoundedOutOfOrdernessGenerator());        KeyedStream<Tuple2<String, Long>, Tuple> keyed = tuple2.keyBy(0);        WindowedStream<Tuple2<String, Long>, Tuple, TimeWindow> windowStream = keyed.window(TumblingEventTimeWindows.of(Time.seconds(10)));        DataStream<Object> window = windowStream.apply(new WindowFunction<Tuple2<String,Long>, Object, Tuple, TimeWindow>() {            private static final long serialVersionUID = 1586476475958616739L;            @Override            public void apply(Tuple tuple, TimeWindow timeWindow, Iterable<Tuple2<String, Long>> iterable, Collector<Object> collector) throws Exception {                List<Long> time = new ArrayList<>();                for(Tuple2<String, Long> tuple2:iterable){                    time.add(tuple2.getField(1));                }                Collections.sort(time);                collector.collect(new Tuple6<>(tuple, time.size(), format.format(time.get(0)), format.format(time.get(time.size() - 1)), format.format(timeWindow.getStart()), format.format(timeWindow.getEnd())));            }        });        window.print();        try {            env.execute();        } catch (Exception e) {            e.printStackTrace();        }    }}